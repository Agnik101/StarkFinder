{
  "meta": {
    "source": "github",
    "repo": {
      "url": "https://github.com/argentlabs/argent-contracts-starknet",
      "stars": 175,
      "forks": 72,
      "last_commit": "2025-08-14T12:14:00Z",
      "archived": false,
      "full_name": "argentlabs/argent-contracts-starknet"
    }
  },
  "files": [
    {
      "path": "src/account.cairo",
      "code": "use argent::signer::signer_signature::Signer;\nuse starknet::account::Call;\n\npub const SRC5_ACCOUNT_INTERFACE_ID: felt252 = 0x2ceccef7f994940b3962a6c67e0ba4fcd37df7d131417c604f91e03caecc1cd;\npub const SRC5_ACCOUNT_INTERFACE_ID_OLD_1: felt252 = 0xa66bd575;\npub const SRC5_ACCOUNT_INTERFACE_ID_OLD_2: felt252 = 0x3943f10f;\n\n#[derive(Serde, Copy, Drop)]\npub struct Version {\n    pub major: u8,\n    pub minor: u8,\n    pub patch: u8,\n}\n\n#[starknet::interface]\npub trait IAccount<TContractState> {\n    fn __validate__(ref self: TContractState, calls: Array<Call>) -> felt252;\n    fn __execute__(ref self: TContractState, calls: Array<Call>);\n\n    /// @notice Checks whether a given signature for a given hash is valid\n    /// @dev Warning: To guarantee the signature cannot be replayed in other accounts or other chains, the data hashed\n    /// must be unique to the account and the chain.\n    /// This is true today for starknet transaction signatures and for SNIP-12 signatures but might not be true for\n    /// other types of signatures @param hash The hash of the data to sign\n    /// @param signature The signature to validate\n    /// @return The shortstring 'VALID' when the signature is valid, 0 if the signature doesn't match the hash\n    /// @dev it can also panic if the signature is not in a valid format\n    fn is_valid_signature(self: @TContractState, hash: felt252, signature: Array<felt252>) -> felt252;\n}\n\n#[starknet::interface]\npub trait IArgentAccount<TContractState> {\n    fn __validate_declare__(self: @TContractState, class_hash: felt252) -> felt252;\n    fn __validate_deploy__(\n        self: @TContractState,\n        class_hash: felt252,\n        contract_address_salt: felt252,\n        threshold: usize,\n        signers: Array<Signer>,\n    ) -> felt252;\n    fn get_name(self: @TContractState) -> felt252;\n    fn get_version(self: @TContractState) -> Version;\n}\n\n/// Deprecated methods for compatibility reasons\n#[starknet::interface]\npub trait IDeprecatedArgentAccount<TContractState> {\n    fn getVersion(self: @TContractState) -> felt252;\n    fn getName(self: @TContractState) -> felt252;\n    /// For compatibility reasons this function returns 1 when the signature is valid, and panics otherwise\n    fn isValidSignature(self: @TContractState, hash: felt252, signatures: Array<felt252>) -> felt252;\n}\n\n\nimpl VersionPartialOrd of PartialOrd<Version> {\n    fn lt(lhs: Version, rhs: Version) -> bool {\n        if lhs.major != rhs.major {\n            return lhs.major < rhs.major;\n        }\n        if lhs.minor != rhs.minor {\n            return lhs.minor < rhs.minor;\n        }\n        return lhs.patch < rhs.patch;\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "src/introspection.cairo",
      "code": "pub const SRC5_INTERFACE_ID: felt252 = 0x3f918d17e5ee77373b56385708f855659a07f75997f365cf87748628532a055;\npub const SRC5_INTERFACE_ID_OLD: felt252 = 0x01ffc9a7;\n\n#[starknet::interface]\npub trait ISRC5<TContractState> {\n    fn supports_interface(self: @TContractState, interface_id: felt252) -> bool;\n}\n\n#[starknet::interface]\npub trait ISRC5Legacy<TContractState> {\n    fn supportsInterface(self: @TContractState, interfaceId: felt252) -> felt252;\n}\n\n#[starknet::component]\npub mod src5_component {\n    use argent::account::{SRC5_ACCOUNT_INTERFACE_ID, SRC5_ACCOUNT_INTERFACE_ID_OLD_1, SRC5_ACCOUNT_INTERFACE_ID_OLD_2};\n    use argent::introspection::{ISRC5, ISRC5Legacy, SRC5_INTERFACE_ID, SRC5_INTERFACE_ID_OLD};\n    use argent::outside_execution::outside_execution::{\n        ERC165_OUTSIDE_EXECUTION_INTERFACE_ID_REV_0, ERC165_OUTSIDE_EXECUTION_INTERFACE_ID_REV_1,\n    };\n\n    #[storage]\n    pub struct Storage {}\n\n    #[embeddable_as(SRC5Impl)]\n    impl SRC5<TContractState, +HasComponent<TContractState>> of ISRC5<ComponentState<TContractState>> {\n        fn supports_interface(self: @ComponentState<TContractState>, interface_id: felt252) -> bool {\n            if interface_id == SRC5_INTERFACE_ID {\n                true\n            } else if interface_id == SRC5_ACCOUNT_INTERFACE_ID {\n                true\n            } else if interface_id == ERC165_OUTSIDE_EXECUTION_INTERFACE_ID_REV_0 {\n                true\n            } else if interface_id == ERC165_OUTSIDE_EXECUTION_INTERFACE_ID_REV_1 {\n                true\n            } else if interface_id == SRC5_INTERFACE_ID_OLD {\n                true\n            } else if interface_id == SRC5_ACCOUNT_INTERFACE_ID_OLD_1 {\n                true\n            } else if interface_id == SRC5_ACCOUNT_INTERFACE_ID_OLD_2 {\n                true\n            } else {\n                false\n            }\n        }\n    }\n\n    #[embeddable_as(SRC5LegacyImpl)]\n    impl SRC5Legacy<TContractState, +HasComponent<TContractState>> of ISRC5Legacy<ComponentState<TContractState>> {\n        fn supportsInterface(self: @ComponentState<TContractState>, interfaceId: felt252) -> felt252 {\n            if self.supports_interface(interfaceId) {\n                1\n            } else {\n                0\n            }\n        }\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "src/lib.cairo",
      "code": "pub mod account;\n\npub mod introspection;\npub mod offchain_message;\npub mod recovery;\npub mod upgrade;\n\npub mod signer {\n    pub mod eip191;\n    pub mod signer_signature;\n    pub mod webauthn;\n}\n\npub mod outside_execution {\n    pub mod outside_execution;\n    pub mod outside_execution_hash;\n}\n\npub mod multisig_account {\n    pub mod external_recovery;\n    pub mod multisig_account;\n    pub mod signer_manager;\n    mod upgrade_migration;\n}\n\npub mod multiowner_account {\n    pub mod account_interface;\n    pub mod argent_account;\n    pub mod events;\n    pub mod guardian_manager;\n    pub mod owner_alive;\n    pub mod owner_manager;\n    pub mod recovery;\n    pub mod signer_storage_linked_set;\n    pub mod upgrade_migration;\n}\n\npub mod linked_set {\n    pub mod linked_set;\n    pub mod linked_set_with_head;\n}\n\npub mod utils {\n    pub mod array_ext;\n    pub mod asserts;\n    pub mod bytes;\n    pub mod calls;\n    pub mod hashing;\n    pub mod serialization;\n    pub mod transaction_version;\n}\n\n\npub mod session {\n    pub mod session;\n    pub mod session_hash;\n}\n\n\npub mod mocks {\n    mod future_argent_account;\n    mod future_argent_multisig;\n    pub mod linked_set_mock;\n    mod mock_dapp;\n    mod multiowner_mock;\n    pub mod multisig_mocks;\n    mod recovery_mocks;\n    pub mod src5_mocks;\n    mod stable_address_deployer_mock;\n}\n\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "src/linked_set/linked_set.cairo",
      "code": "use starknet::Store;\nuse starknet::storage::{\n    Mutable, PendingStoragePathTrait, StorageAsPath, StorageBase, StoragePath, StoragePointerWriteAccess,\n};\n///\n/// A LinkedSet is storage structure that allows to store multiple items making it efficient to check if an item is in\n/// the set. LinkedSet doesn't allow duplicate items. The order of the items is preserved.\n/// In terms of storage. It will use the same number of storage slots as storing all items in succession plus the\n/// equivalent of another item to store the end marker.\n/// Searching a given item in the list can be done with O(1) complexity, that means that we only need to check the\n/// storage once regardless of the set size. Items on the list must provide a hash function. So each item provides a\n/// unique hash.\n/// The implementation is based on a having one item \"pointing\" at the next one. 0 points to the first item, and the\n/// last item points to the end marker.\n///\n/// If we have the items A, B and C the memory will look like this\n///\n/// storage address ->    value\n/// -------------------------------\n///        0        ->      A\n///      hash(A)    ->      B\n///      hash(B)    ->      C\n///      hash(C)    ->  END_MARKER\n///\n///\n/// It is critical that the hash function is uniformly distributed, because if the hash returned is invalid it might\n/// corrupt the set. For instance if the hash returns the values 1,2,3 for the items A,B,C and storing each item uses 2\n/// storage slots, when writing one item we might be overriding the storage of other items\n///\n#[phantom]\npub struct LinkedSet<T> {}\n\npub trait LinkedSetRead<TMemberState> {\n    type Value;\n    /// @return number of items in the set\n    fn len(self: TMemberState) -> usize;\n    /// @return true if the set has no items\n    fn is_empty(self: TMemberState) -> bool;\n    /// @return true if the item is in the set\n    /// @param item_hash the hash of the item to check\n    fn contains(self: TMemberState, item_hash: felt252) -> bool;\n    /// @return first item on the set or None if the set is empty\n    fn first(self: TMemberState) -> Option<Self::Value>;\n    /// @return the hashes of all items in the set\n    fn get_all_hashes(self: TMemberState) -> Array<felt252>;\n    /// @returns all the items in the set\n    fn get_all(self: TMemberState) -> Array<Self::Value>;\n}\n\npub trait LinkedSetWrite<TMemberState> {\n    type Value;\n    /// Adds an item at the end of the set.\n    /// @dev It will panic if the item is already in the set\n    /// @returns the hash of the inserted item which is now the latest item on the list\n    /// @param item the item to add\n    fn insert(self: TMemberState, item: Self::Value) -> felt252;\n    /// Adds multiple items to the end of the set.\n    /// @dev It will panic if any of the items is already in the set\n    /// @param items_to_add the items to add\n    fn insert_many(self: TMemberState, items_to_add: Span<Self::Value>);\n    /// Removes an item from the set.\n    /// @dev It will panic if the item is not in the set\n    /// @param item_hash the hash of the item to remove\n    fn remove(self: TMemberState, item_hash: felt252);\n    /// Removes multiple items from the set.\n    /// @dev It will panic if any of the items is not in the set\n    /// @param items_hashes_to_remove the hashes of the items to remove\n    fn remove_many(self: TMemberState, items_hashes_to_remove: Span<felt252>);\n}\n\n///\n/// Needed to setup a LinkedSet for a given type\n/// The implementation must be correct otherwise it might corrupt the set\n///\npub trait LinkedSetConfig<T> {\n    /// An item that represent the end of the list. It must be an invalid item according to the `is_valid_item` function\n    const END_MARKER: T;\n\n    // Check if the item is valid. Otherwise it can't be added to the set\n    fn is_valid_item(self: @T) -> bool;\n\n    /// @notice returns a unique hash for the given item. The hash can't be zero as it's reserved for the first item\n    /// @dev It is critical that the hash function is uniformly distributed, because if the hash returned is invalid it\n    /// might corrupt the set. For instance if the hash returns the values 1,2,3 for the items A,B,C and storing each\n    /// item uses 2 storage slots. when writing one item we might e overriding the storage of other items\n    /// @param self the item to hash\n    /// @return the item hash\n    fn hash(self: @T) -> felt252;\n\n    // @notice reads the value stored at the given StoragePath\n    // @dev must return valid items according to the `is_valid_item` function\n    // @param path the path to read\n    // @returns the value stored at the given path or None if the path is empty\n    fn path_read_value(path: StoragePath<T>) -> Option<T>;\n\n    // @return true when the value stored in the given path is valid or the end marker\n    // @param path the path determined by the hash of the item we want to check inclusion\n    fn path_is_in_set(path: StoragePath<T>) -> bool;\n}\n\n///\n/// Used to add the end marker.\n/// For upgrade purposes only\n/// The implementation must be correct to avoid corrupting the linked set\n///\npub trait IAddEndMarker<TMemberState> {\n    /// @notice This is used during upgrades to ensure the linked set is correctly terminated.\n    fn add_end_marker(self: TMemberState);\n}\n\nimpl AddEndMarkerImpl<\n    T, +Drop<T>, +PartialEq<T>, +Copy<T>, +Store<T>, +LinkedSetConfig<T>, +Default<T>,\n> of IAddEndMarker<StorageBase<Mutable<LinkedSet<T>>>> {\n    fn add_end_marker(self: StorageBase<Mutable<LinkedSet<T>>>) {\n        let last_signer = self.find_last_hash();\n        if last_signer != 0 {\n            self.entry(last_signer).write(LinkedSetConfig::END_MARKER);\n        }\n    }\n}\n\npub impl LinkedSetReadImpl<\n    T, +Drop<T>, +PartialEq<T>, +Store<T>, +LinkedSetConfig<T>,\n> of LinkedSetRead<StorageBase<LinkedSet<T>>> {\n    type Value = T;\n\n    fn is_empty(self: StorageBase<LinkedSet<T>>) -> bool {\n        self.first().is_none()\n    }\n\n    fn contains(self: StorageBase<LinkedSet<T>>, item_hash: felt252) -> bool {\n        if item_hash == 0 {\n            return false;\n        }\n        LinkedSetConfig::path_is_in_set(path: self.entry(item_hash))\n    }\n\n    fn len(self: StorageBase<LinkedSet<T>>) -> usize {\n        let mut current_item_hash = 0;\n        let mut size = 0;\n        while let Option::Some(next_item) = self.next(current_item_hash) {\n            current_item_hash = next_item.hash();\n            size += 1;\n        };\n        size\n    }\n\n    fn first(self: StorageBase<LinkedSet<T>>) -> Option<T> {\n        self.next(item_hash: 0)\n    }\n\n    fn get_all_hashes(self: StorageBase<LinkedSet<T>>) -> Array<felt252> {\n        let mut current_item_hash = 0;\n        let mut all_hashes = array![];\n        while let Option::Some(next_item) = self.next(current_item_hash) {\n            current_item_hash = next_item.hash();\n            all_hashes.append(current_item_hash);\n        };\n        all_hashes\n    }\n\n    fn get_all(self: StorageBase<LinkedSet<T>>) -> Array<T> {\n        let mut current_item_hash = 0;\n        let mut all_items = array![];\n        while let Option::Some(next_item) = self.next(current_item_hash) {\n            current_item_hash = next_item.hash();\n            all_items.append(next_item);\n        };\n        all_items\n    }\n}\n\n#[generate_trait]\npub impl LinkedSetReadPrivateImpl<\n    T, +Drop<T>, +PartialEq<T>, +Store<T>, +LinkedSetConfig<T>,\n> of LinkedSetReadPrivate<T> {\n    fn entry(self: StorageBase<LinkedSet<T>>, item_hash: felt252) -> StoragePath<T> {\n        PendingStoragePathTrait::new(@self.as_path(), item_hash).as_path()\n    }\n\n    fn next(self: StorageBase<LinkedSet<T>>, item_hash: felt252) -> Option<T> {\n        LinkedSetConfig::path_read_value(path: self.entry(item_hash))\n    }\n\n    // Return the last item hash or zero when the list is empty. Cost increases with the list size\n    fn find_last_hash(self: StorageBase<LinkedSet<T>>) -> felt252 {\n        let mut current_item_hash = 0;\n        while let Option::Some(next_item) = self.next(current_item_hash) {\n            current_item_hash = next_item.hash();\n        };\n        current_item_hash\n    }\n\n    fn item_hash_before(self: StorageBase<LinkedSet<T>>, item_hash_after: felt252) -> felt252 {\n        assert(item_hash_after != 0, 'linked-set/item-hash-after');\n        let mut current_item_hash = 0;\n        loop {\n            let next_item = self.next(current_item_hash).expect('linked-set/item-not-found');\n            let next_item_hash = next_item.hash();\n            if next_item_hash == item_hash_after {\n                break current_item_hash;\n            }\n            current_item_hash = next_item_hash;\n        }\n    }\n}\n\npub impl LinkedSetWriteImpl<\n    T, +Drop<T>, +PartialEq<T>, +Copy<T>, +Store<T>, +LinkedSetConfig<T>, +Default<T>,\n> of LinkedSetWrite<StorageBase<Mutable<LinkedSet<T>>>> {\n    type Value = T;\n\n    fn insert(self: StorageBase<Mutable<LinkedSet<T>>>, item: T) -> felt252 {\n        self.insert_opt(:item, last_item_hash: self.find_last_hash())\n    }\n\n    fn insert_many(self: StorageBase<Mutable<LinkedSet<T>>>, items_to_add: Span<T>) {\n        let mut last_item_hash: felt252 = self.find_last_hash();\n        for item in items_to_add {\n            last_item_hash = self.insert_opt(item: *item, :last_item_hash);\n        };\n    }\n\n    fn remove_many(self: StorageBase<Mutable<LinkedSet<T>>>, items_hashes_to_remove: Span<felt252>) {\n        for item_hash in items_hashes_to_remove {\n            self.remove(item_hash: *item_hash);\n        };\n    }\n\n    fn remove(self: StorageBase<Mutable<LinkedSet<T>>>, item_hash: felt252) {\n        assert(item_hash != 0, 'linked-set/invalid-hash-to-rem');\n\n        // Previous item set to the next item in the list\n        let previous_item_hash = self.item_hash_before(item_hash);\n\n        if let Option::Some(next_item) = self.next(item_hash) {\n            // Removing an item in the middle\n            self.entry(previous_item_hash).write(next_item);\n        } else {\n            // Removing the last item\n            self.entry(previous_item_hash).write(LinkedSetConfig::END_MARKER);\n        }\n        // removed pointer set to empty\n        self.entry(item_hash).write(Default::default());\n    }\n}\n\n#[generate_trait]\npub impl LinkedSetWritePrivateImpl<\n    T, +Drop<T>, +PartialEq<T>, +Copy<T>, +Store<T>, +LinkedSetConfig<T>, +Default<T>,\n> of LinkedSetWritePrivate<T> {\n    fn entry(self: StorageBase<Mutable<LinkedSet<T>>>, item_hash: felt252) -> StoragePath<Mutable<T>> {\n        PendingStoragePathTrait::new(@self.as_path(), item_hash).as_path()\n    }\n\n    fn insert_opt(self: StorageBase<Mutable<LinkedSet<T>>>, item: T, last_item_hash: felt252) -> felt252 {\n        assert(item.is_valid_item(), 'linked-set/invalid-item');\n        let item_hash = item.hash();\n        let is_duplicate = self.contains(:item_hash);\n        assert(!is_duplicate, 'linked-set/already-in-set');\n        self.entry(last_item_hash).write(item);\n        self.entry(item_hash).write(LinkedSetConfig::END_MARKER);\n        item_hash\n    }\n\n    // Allow easy access to the read-only version of the storage\n    fn item_hash_before(self: StorageBase<Mutable<LinkedSet<T>>>, item_hash_after: felt252) -> felt252 {\n        self.as_read_only().item_hash_before(:item_hash_after)\n    }\n\n    fn next(self: StorageBase<Mutable<LinkedSet<T>>>, item_hash: felt252) -> Option<T> {\n        self.as_read_only().next(:item_hash)\n    }\n\n    fn find_last_hash(self: StorageBase<Mutable<LinkedSet<T>>>) -> felt252 {\n        self.as_read_only().find_last_hash()\n    }\n}\n\n#[generate_trait]\npub impl StorageBaseAsReadOnlyImpl<T> of StorageBaseAsReadOnly<T> {\n    fn as_read_only(self: StorageBase<Mutable<T>>) -> StorageBase<T> {\n        StorageBase { __base_address__: self.__base_address__ }\n    }\n}\n\n// Allow read operations in mutable access too\npub impl MutableLinkedSetReadImpl<\n    T, +Drop<T>, +PartialEq<T>, +Store<T>, +LinkedSetConfig<T>,\n> of LinkedSetRead<StorageBase<Mutable<LinkedSet<T>>>> {\n    type Value = T;\n\n    fn is_empty(self: StorageBase<Mutable<LinkedSet<T>>>) -> bool {\n        self.as_read_only().is_empty()\n    }\n\n    fn contains(self: StorageBase<Mutable<LinkedSet<T>>>, item_hash: felt252) -> bool {\n        self.as_read_only().contains(:item_hash)\n    }\n\n    fn len(self: StorageBase<Mutable<LinkedSet<T>>>) -> usize {\n        self.as_read_only().len()\n    }\n\n    fn first(self: StorageBase<Mutable<LinkedSet<T>>>) -> Option<T> {\n        self.as_read_only().first()\n    }\n\n    fn get_all_hashes(self: StorageBase<Mutable<LinkedSet<T>>>) -> Array<felt252> {\n        self.as_read_only().get_all_hashes()\n    }\n\n    fn get_all(self: StorageBase<Mutable<LinkedSet<T>>>) -> Array<T> {\n        self.as_read_only().get_all()\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "src/linked_set/linked_set_with_head.cairo",
      "code": "use argent::linked_set::linked_set::{\n    LinkedSet, LinkedSetConfig, LinkedSetReadImpl, LinkedSetWriteImpl, MutableLinkedSetReadImpl,\n    StorageBaseAsReadOnlyImpl,\n};\nuse argent::utils::array_ext::ArrayExtTrait;\nuse starknet::Store;\nuse starknet::storage::{Mutable, StorageAsPath, StorageBase, StoragePath, StoragePointerWriteAccess};\n\n///\n/// A LinkedSetWithHead is storage structure that allows to store multiple items making it efficient to check if an item\n/// is in the set.\n/// LinkedSet doesn't allow duplicate items.\n/// The order of the items is preserved.\n/// It builds on top of LinkedSet but stores the first item, the head, separately. This means:\n/// - Storing just one item is cheap because it doesn't need to store the end marker. Uses the same amount of storage as\n/// a LinkedSet for larger sets\n/// - Checking if an item is in the set is O(1) complexity. Its a bit more expensive than LinkedSet but\n/// still very efficient. It offers better performance than LinkedSet when the set is a single item\n///\n/// This is how the storage looks like depending on the number of items in the set:\n///\n/// Storing 1 item:  head=A , tail= []\n/// Storing 2 items: head=A , tail= [B]\n/// Storing 3 items: head=A , tail= [B, C]\n///\n#[phantom]\npub struct LinkedSetWithHead<T> {}\n\npub trait LinkedSetWithHeadRead<TMemberState> {\n    type Value;\n    /// @returns the first item in the set or None if the set is empty\n    fn first(self: TMemberState) -> Option<Self::Value>;\n    /// @returns the only item in the set or None if the set is empty or contains more than one item\n    fn single(self: TMemberState) -> Option<Self::Value>;\n    /// @returns the number of items in the set\n    fn len(self: TMemberState) -> usize;\n    /// @returns true if the set is empty\n    fn is_empty(self: TMemberState) -> bool;\n    /// @returns true if the item is in the set\n    /// @param item The item to check inclusion\n    fn contains(self: TMemberState, item: Self::Value) -> bool;\n    /// @returns true if the item is in the set (using the item hash)\n    /// @param item_hash The hash of the item to check inclusion\n    fn contains_by_hash(self: TMemberState, item_hash: felt252) -> bool;\n    /// @returns all the hashes in the set\n    fn get_all_hashes(self: TMemberState) -> Array<felt252>;\n    /// @returns all the items in the set\n    fn get_all(self: TMemberState) -> Array<Self::Value>;\n}\n\npub trait LinkedSetWithHeadWrite<TMemberState> {\n    type Value;\n    /// Adds an item to the set\n    /// @dev It will panic if the item is already in the set\n    /// @param item The item to add\n    /// @returns the hash of the added item\n    fn insert(self: TMemberState, item: Self::Value) -> felt252;\n    /// Removes an item from the set\n    /// @dev It will panic if the item is not in the set\n    /// @param item_hash The hash of the item to remove\n    fn remove(self: TMemberState, item_hash: felt252);\n}\n\n\npub impl LinkedSetWithHeadReadImpl<\n    T, +Drop<T>, +Copy<T>, +PartialEq<T>, +starknet::Store<T>, +LinkedSetConfig<T>,\n> of LinkedSetWithHeadRead<StorageBase<LinkedSetWithHead<T>>> {\n    type Value = T;\n\n    #[inline(always)]\n    fn first(self: StorageBase<LinkedSetWithHead<T>>) -> Option<T> {\n        LinkedSetConfig::path_read_value(path: self.head_entry())\n    }\n\n    fn single(self: StorageBase<LinkedSetWithHead<T>>) -> Option<T> {\n        if !self.get_tail_list().is_empty() {\n            return Option::None; // More than one item\n        }\n        self.first()\n    }\n\n    fn len(self: StorageBase<LinkedSetWithHead<T>>) -> usize {\n        if self.is_empty() {\n            return 0;\n        }\n        1 + self.get_tail_list().len()\n    }\n\n    fn is_empty(self: StorageBase<LinkedSetWithHead<T>>) -> bool {\n        self.first().is_none()\n    }\n\n    fn contains(self: StorageBase<LinkedSetWithHead<T>>, item: T) -> bool {\n        let first_item = if let Option::Some(value) = self.first() {\n            value\n        } else {\n            return false; // empty collection\n        };\n\n        if first_item == item {\n            return true;\n        }\n        self.get_tail_list().contains(item_hash: item.hash())\n    }\n\n    fn contains_by_hash(self: StorageBase<LinkedSetWithHead<T>>, item_hash: felt252) -> bool {\n        let first_item = if let Option::Some(value) = self.first() {\n            value\n        } else {\n            return false; // empty collection\n        };\n\n        if first_item.hash() == item_hash {\n            return true;\n        }\n\n        self.get_tail_list().contains(item_hash)\n    }\n\n    fn get_all_hashes(self: StorageBase<LinkedSetWithHead<T>>) -> Array<felt252> {\n        if let Option::Some(first_item) = self.first() {\n            let mut all_hashes = array![first_item.hash()];\n            all_hashes.append_all(self.get_tail_list().get_all_hashes().span());\n            all_hashes\n        } else {\n            // empty collection\n            array![]\n        }\n    }\n\n    fn get_all(self: StorageBase<LinkedSetWithHead<T>>) -> Array<T> {\n        if let Option::Some(first_item) = self.first() {\n            let mut all_items = array![first_item];\n            all_items.append_all(self.get_tail_list().get_all().span());\n            all_items\n        } else {\n            // empty collection\n            array![]\n        }\n    }\n}\n\n#[generate_trait]\nimpl LinkedSetWithHeadReadPrivateImpl<\n    T, +Drop<T>, +PartialEq<T>, +starknet::Store<T>, +LinkedSetConfig<T>,\n> of LinkedSetWithHeadReadPrivate<T> {\n    #[inline(always)]\n    fn head_entry(self: StorageBase<LinkedSetWithHead<T>>) -> StoragePath<T> {\n        StorageBase { __base_address__: self.__base_address__ }.as_path()\n    }\n\n    fn get_tail_list(self: StorageBase<LinkedSetWithHead<T>>) -> StorageBase<LinkedSet<T>> {\n        StorageBase { __base_address__: self.__base_address__ + 1 }\n    }\n}\n\npub impl LinkedSetWithHeadWriteImpl<\n    T, +Drop<T>, +PartialEq<T>, +Copy<T>, +Store<T>, +LinkedSetConfig<T>, +Default<T>,\n> of LinkedSetWithHeadWrite<StorageBase<Mutable<LinkedSetWithHead<T>>>> {\n    type Value = T;\n\n    fn insert(self: StorageBase<Mutable<LinkedSetWithHead<T>>>, item: T) -> felt252 {\n        if let Option::Some(first_item) = self.first() {\n            assert(item != first_item, 'linked-set/already-in-set');\n            self.get_tail_list().insert(item)\n        } else {\n            // Empty list\n            assert(item.is_valid_item(), 'linked-set/invalid-item');\n            self.head_entry().write(item);\n            item.hash()\n        }\n    }\n\n    fn remove(self: StorageBase<Mutable<LinkedSetWithHead<T>>>, item_hash: felt252) {\n        let head_item = self.first().expect('linked-set/item-not-found');\n        if head_item.hash() == item_hash {\n            // Removing head item\n            let first_in_tail = self.get_tail_list().first();\n            if let Option::Some(first_in_tail) = first_in_tail {\n                // Move first tail item to the head\n                self.head_entry().write(first_in_tail); // overwrite the head\n                self.get_tail_list().remove(first_in_tail.hash());\n            } else {\n                // Tail is empty. Remove the head and leave an empty set\n                self.head_entry().write(Default::default());\n            }\n        } else {\n            // Item is not the head\n            self.get_tail_list().remove(item_hash);\n        };\n    }\n}\n\n#[generate_trait]\nimpl LinkedSetWithHeadWritePrivateImpl<\n    T, +Drop<T>, +PartialEq<T>, +Copy<T>, +Store<T>, +LinkedSetConfig<T>, +Default<T>,\n> of LinkedSetWithHeadWritePrivate<T> {\n    fn head_entry(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> StoragePath<Mutable<T>> {\n        StorageBase { __base_address__: self.__base_address__ }.as_path()\n    }\n\n    fn get_tail_list(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> StorageBase<Mutable<LinkedSet<T>>> {\n        StorageBase { __base_address__: self.__base_address__ + 1 }\n    }\n}\n\n// Allow read operations in mutable access too\npub impl MutableLinkedSetWithHeadReadImpl<\n    T, +Drop<T>, +Copy<T>, +PartialEq<T>, +Store<T>, +LinkedSetConfig<T>,\n> of LinkedSetWithHeadRead<StorageBase<Mutable<LinkedSetWithHead<T>>>> {\n    type Value = T;\n\n    fn first(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> Option<T> {\n        self.as_read_only().first()\n    }\n\n    fn single(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> Option<T> {\n        self.as_read_only().single()\n    }\n\n    fn len(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> usize {\n        self.as_read_only().len()\n    }\n\n    fn is_empty(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> bool {\n        self.as_read_only().is_empty()\n    }\n\n    fn contains(self: StorageBase<Mutable<LinkedSetWithHead<T>>>, item: T) -> bool {\n        self.as_read_only().contains(:item)\n    }\n\n    fn contains_by_hash(self: StorageBase<Mutable<LinkedSetWithHead<T>>>, item_hash: felt252) -> bool {\n        self.as_read_only().contains_by_hash(:item_hash)\n    }\n\n    fn get_all_hashes(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> Array<felt252> {\n        self.as_read_only().get_all_hashes()\n    }\n\n    fn get_all(self: StorageBase<Mutable<LinkedSetWithHead<T>>>) -> Array<T> {\n        self.as_read_only().get_all()\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    }
  ]
}