{
  "meta": {
    "source": "github",
    "repo": {
      "url": "https://github.com/kkrt-labs/kakarot",
      "stars": 1005,
      "forks": 319,
      "last_commit": "2025-01-09T08:06:30Z",
      "archived": true,
      "full_name": "kkrt-labs/kakarot"
    }
  },
  "files": [
    {
      "path": "cairo/kakarot-ssj/crates/alexandria_data_structures/src/lib.cairo",
      "code": "pub mod vec;\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "cairo/kakarot-ssj/crates/alexandria_data_structures/src/vec.cairo",
      "code": "use core::nullable::NullableImpl;\nuse core::num::traits::WrappingAdd;\nuse core::ops::index::Index;\n\n//! Vec implementation.\n//!\n//! # Example\n//! ```\n//! use alexandria::data_structures::vec::VecTrait;\n//!\n//! // Create a new vec instance.\n//! let mut vec = Felt252Vec::<u128>::new();\n//! // Push some items to the vec.\n//! vec.push(1);\n//! vec.push(2);\n//! ...\n//! ```\n\npub trait VecTrait<V, T> {\n    /// Creates a new V instance.\n    /// Returns\n    /// * V The new vec instance.\n    fn new() -> V;\n\n    /// Returns the item at the given index, or None if the index is out of bounds.\n    /// Parameters\n    /// * self The vec instance.\n    /// * index The index of the item to get.\n    /// Returns\n    /// * Option<T> The item at the given index, or None if the index is out of bounds.\n    fn get(ref self: V, index: usize) -> Option<T>;\n\n    /// Returns the item at the given index, or panics if the index is out of bounds.\n    /// Parameters\n    /// * self The vec instance.\n    /// * index The index of the item to get.\n    /// Returns\n    /// * T The item at the given index.\n    fn at(ref self: V, index: usize) -> T;\n\n    /// Pushes a new item to the vec.\n    /// Parameters\n    /// * self The vec instance.\n    /// * value The value to push onto the vec.\n    fn push(ref self: V, value: T);\n\n    /// Sets the item at the given index to the given value.\n    /// Panics if the index is out of bounds.\n    /// Parameters\n    /// * self The vec instance.\n    /// * index The index of the item to set.\n    /// * value The value to set the item to.\n    fn set(ref self: V, index: usize, value: T);\n\n    /// Returns the length of the vec.\n    /// Parameters\n    /// * self The vec instance.\n    /// Returns\n    /// * usize The length of the vec.\n    fn len(self: @V) -> usize;\n}\n\nimpl VecIndex<V, T, +VecTrait<V, T>> of Index<V, usize> {\n    type Target = T;\n\n    #[inline(always)]\n    fn index(ref self: V, index: usize) -> T {\n        self.at(index)\n    }\n}\n\npub struct Felt252Vec<T> {\n    pub items: Felt252Dict<T>,\n    pub len: usize,\n}\n\nimpl DefaultFeltVec<T, +Drop<T>, +Copy<T>, +Felt252DictValue<T>> of Default<Felt252Vec<T>> {\n    fn default() -> Felt252Vec<T> {\n        Felt252VecImpl::<T>::new()\n    }\n}\n\nimpl DestructFeltVec<T, +Drop<T>, +Felt252DictValue<T>> of Destruct<Felt252Vec<T>> {\n    fn destruct(self: Felt252Vec<T>) nopanic {\n        self.items.squash();\n    }\n}\n\n\nimpl Felt252VecImpl<T, +Drop<T>, +Copy<T>, +Felt252DictValue<T>> of VecTrait<Felt252Vec<T>, T> {\n    fn new() -> Felt252Vec<T> {\n        Felt252Vec { items: Default::default(), len: 0 }\n    }\n\n    fn get(ref self: Felt252Vec<T>, index: usize) -> Option<T> {\n        if index < self.len() {\n            let item = self.items.get(index.into());\n            Option::Some(item)\n        } else {\n            Option::None\n        }\n    }\n\n    fn at(ref self: Felt252Vec<T>, index: usize) -> T {\n        assert(index < self.len(), 'Index out of bounds');\n        let item = self.items.get(index.into());\n        item\n    }\n\n    fn push(ref self: Felt252Vec<T>, value: T) {\n        self.items.insert(self.len.into(), value);\n        self.len = self.len.wrapping_add(1);\n    }\n\n    fn set(ref self: Felt252Vec<T>, index: usize, value: T) {\n        assert(index < self.len(), 'Index out of bounds');\n        self.items.insert(index.into(), value);\n    }\n\n    fn len(self: @Felt252Vec<T>) -> usize {\n        *self.len\n    }\n}\n\npub struct NullableVec<T> {\n    items: Felt252Dict<Nullable<T>>,\n    len: usize,\n}\n\nimpl DestructNullableVec<T, +Drop<T>> of Destruct<NullableVec<T>> {\n    fn destruct(self: NullableVec<T>) nopanic {\n        self.items.squash();\n    }\n}\n\nimpl NullableVecImpl<T, +Drop<T>, +Copy<T>> of VecTrait<NullableVec<T>, T> {\n    fn new() -> NullableVec<T> {\n        NullableVec { items: Default::default(), len: 0 }\n    }\n\n    fn get(ref self: NullableVec<T>, index: usize) -> Option<T> {\n        if index < self.len() {\n            Option::Some(self.items.get(index.into()).deref())\n        } else {\n            Option::None\n        }\n    }\n\n    fn at(ref self: NullableVec<T>, index: usize) -> T {\n        assert(index < self.len(), 'Index out of bounds');\n        self.items.get(index.into()).deref()\n    }\n\n    fn push(ref self: NullableVec<T>, value: T) {\n        self.items.insert(self.len.into(), NullableImpl::new(value));\n        self.len = self.len.wrapping_add(1);\n    }\n\n    fn set(ref self: NullableVec<T>, index: usize, value: T) {\n        assert(index < self.len(), 'Index out of bounds');\n        self.items.insert(index.into(), NullableImpl::new(value));\n    }\n\n    fn len(self: @NullableVec<T>) -> usize {\n        *self.len\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "cairo/kakarot-ssj/crates/contracts/src/account_contract.cairo",
      "code": "//! The generic account that is deployed by Kakarot Core before being \"specialized\" into an\n//! Externally Owned Account or a Contract Account This aims at having only one class hash for all\n//! the contracts deployed by Kakarot, thus enforcing a unique and consistent address mapping Eth\n//! Address <=> Starknet Address\n\nuse core::starknet::account::{Call};\nuse core::starknet::{EthAddress, ClassHash, ContractAddress};\n\n#[derive(Copy, Drop, Serde, Debug)]\npub struct OutsideExecution {\n    pub caller: ContractAddress,\n    pub nonce: u64,\n    pub execute_after: u64,\n    pub execute_before: u64,\n    pub calls: Span<Call>\n}\n\n#[starknet::interface]\npub trait IAccount<TContractState> {\n    fn initialize(\n        ref self: TContractState, evm_address: EthAddress, implementation_class: ClassHash\n    );\n    fn get_implementation(self: @TContractState) -> ClassHash;\n    fn get_evm_address(self: @TContractState) -> EthAddress;\n    fn get_code_hash(self: @TContractState) -> u256;\n    fn set_code_hash(ref self: TContractState, code_hash: u256);\n    fn is_initialized(self: @TContractState) -> bool;\n\n    // EOA functions\n    fn __validate__(ref self: TContractState, calls: Array<Call>) -> felt252;\n    fn __validate_declare__(self: @TContractState, class_hash: felt252) -> felt252;\n    fn __execute__(ref self: TContractState, calls: Array<Call>) -> Array<Span<felt252>>;\n\n    // CA functions\n    fn write_bytecode(ref self: TContractState, bytecode: Span<u8>);\n    fn bytecode(self: @TContractState) -> Span<u8>;\n    fn write_storage(ref self: TContractState, key: u256, value: u256);\n    fn storage(self: @TContractState, key: u256) -> u256;\n    fn get_nonce(self: @TContractState) -> u64;\n    fn set_nonce(ref self: TContractState, nonce: u64);\n    fn execute_starknet_call(ref self: TContractState, call: Call) -> (bool, Span<felt252>);\n    fn execute_from_outside(\n        ref self: TContractState, outside_execution: OutsideExecution, signature: Span<felt252>,\n    ) -> Array<Span<felt252>>;\n}\n\n#[starknet::contract(account)]\npub mod AccountContract {\n    use core::cmp::min;\n    use core::num::traits::Bounded;\n    use core::num::traits::zero::Zero;\n    use core::starknet::account::{Call};\n    use core::starknet::eth_signature::verify_eth_signature;\n    use core::starknet::storage::{\n        Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,\n        StoragePointerWriteAccess\n    };\n    use core::starknet::syscalls::call_contract_syscall;\n    use core::starknet::{\n        EthAddress, ClassHash, get_caller_address, get_tx_info, get_block_timestamp\n    };\n    use crate::components::ownable::IOwnable;\n    use crate::components::ownable::ownable_component::InternalTrait;\n    use crate::components::ownable::ownable_component;\n    use crate::errors::KAKAROT_REENTRANCY;\n    use crate::kakarot_core::eth_rpc::{IEthRPCDispatcher, IEthRPCDispatcherTrait};\n    use crate::kakarot_core::interface::{IKakarotCoreDispatcher, IKakarotCoreDispatcherTrait};\n    use crate::storage::StorageBytecode;\n    use openzeppelin::token::erc20::interface::{IERC20CamelDispatcher, IERC20CamelDispatcherTrait};\n    use super::OutsideExecution;\n    use utils::eth_transaction::transaction::TransactionTrait;\n    use utils::serialization::{deserialize_signature, deserialize_bytes, serialize_bytes};\n    use utils::traits::DefaultSignature;\n\n    // Add ownable component\n    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n    #[abi(embed_v0)]\n    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n    impl OwnableInternal = ownable_component::InternalImpl<ContractState>;\n\n\n    const VERSION: u32 = 000_001_000;\n\n\n    #[storage]\n    pub(crate) struct Storage {\n        pub(crate) Account_bytecode: StorageBytecode,\n        pub(crate) Account_bytecode_len: u32,\n        pub(crate) Account_storage: Map<u256, u256>,\n        pub(crate) Account_is_initialized: bool,\n        pub(crate) Account_nonce: u64,\n        pub(crate) Account_implementation: ClassHash,\n        pub(crate) Account_evm_address: EthAddress,\n        pub(crate) Account_code_hash: u256,\n        #[substorage(v0)]\n        ownable: ownable_component::Storage\n    }\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    pub enum Event {\n        transaction_executed: TransactionExecuted,\n        OwnableEvent: ownable_component::Event\n    }\n\n    #[derive(Drop, starknet::Event, Debug)]\n    pub struct TransactionExecuted {\n        pub response: Span<felt252>,\n        pub success: bool,\n        pub gas_used: u64\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {\n        panic!(\"Accounts cannot be created directly\");\n    }\n\n    #[abi(embed_v0)]\n    impl Account of super::IAccount<ContractState> {\n        fn initialize(\n            ref self: ContractState, evm_address: EthAddress, implementation_class: ClassHash\n        ) {\n            assert(!self.Account_is_initialized.read(), 'Account already initialized');\n            self.Account_is_initialized.write(true);\n\n            self.Account_evm_address.write(evm_address);\n            self.Account_implementation.write(implementation_class);\n\n            let kakarot_address = self.ownable.owner();\n            let kakarot = IKakarotCoreDispatcher { contract_address: kakarot_address };\n            let native_token = kakarot.get_native_token();\n            // To internally perform value transfer of the network's native\n            // token (which conforms to the ERC20 standard), we need to give the\n            // KakarotCore contract infinite allowance\n            IERC20CamelDispatcher { contract_address: native_token }\n                .approve(kakarot_address, Bounded::<u256>::MAX);\n\n            kakarot.register_account(evm_address);\n        }\n\n        fn get_implementation(self: @ContractState) -> ClassHash {\n            self.Account_implementation.read()\n        }\n\n        fn get_evm_address(self: @ContractState) -> EthAddress {\n            self.Account_evm_address.read()\n        }\n\n        fn get_code_hash(self: @ContractState) -> u256 {\n            self.Account_code_hash.read()\n        }\n\n        fn set_code_hash(ref self: ContractState, code_hash: u256) {\n            self.ownable.assert_only_owner();\n            self.Account_code_hash.write(code_hash);\n        }\n\n        fn is_initialized(self: @ContractState) -> bool {\n            self.Account_is_initialized.read()\n        }\n\n        // EOA functions\n        fn __validate__(ref self: ContractState, calls: Array<Call>) -> felt252 {\n            panic!(\"EOA: __validate__ not supported\")\n        }\n\n        /// Validate Declare is not used for Kakarot\n        fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n            panic!(\"EOA: declare not supported\")\n        }\n\n        fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n            panic!(\"EOA: __execute__ not supported\")\n        }\n\n        fn write_bytecode(ref self: ContractState, bytecode: Span<u8>) {\n            self.ownable.assert_only_owner();\n            self.Account_bytecode.write(StorageBytecode { bytecode });\n        }\n\n        fn bytecode(self: @ContractState) -> Span<u8> {\n            self.Account_bytecode.read().bytecode\n        }\n\n        fn write_storage(ref self: ContractState, key: u256, value: u256) {\n            self.ownable.assert_only_owner();\n            self.Account_storage.write(key, value);\n        }\n\n        fn storage(self: @ContractState, key: u256) -> u256 {\n            self.Account_storage.read(key)\n        }\n\n        fn get_nonce(self: @ContractState) -> u64 {\n            self.Account_nonce.read()\n        }\n\n        fn set_nonce(ref self: ContractState, nonce: u64) {\n            self.ownable.assert_only_owner();\n            self.Account_nonce.write(nonce);\n        }\n\n        /// Used to preserve caller in Cairo Precompiles\n        /// Reentrency check is done for Kakarot contract, only get_starknet_address is allowed\n        /// for Solidity contracts to be able to get the corresponding Starknet address in their\n        /// calldata.\n        fn execute_starknet_call(ref self: ContractState, call: Call) -> (bool, Span<felt252>) {\n            self.ownable.assert_only_owner();\n            let kakarot_address = self.ownable.owner();\n            if call.to == kakarot_address && call.selector != selector!(\"get_starknet_address\") {\n                return (false, KAKAROT_REENTRANCY.span());\n            }\n            let response = call_contract_syscall(call.to, call.selector, call.calldata);\n            if response.is_ok() {\n                return (true, response.unwrap().into());\n            }\n            return (false, response.unwrap_err().into());\n        }\n\n        fn execute_from_outside(\n            ref self: ContractState, outside_execution: OutsideExecution, signature: Span<felt252>,\n        ) -> Array<Span<felt252>> {\n            let caller = get_caller_address();\n            let tx_info = get_tx_info();\n\n            // SNIP-9 Validation\n            if (outside_execution.caller.into() != 'ANY_CALLER') {\n                assert(caller == outside_execution.caller, 'SNIP9: Invalid caller');\n            }\n\n            let block_timestamp = get_block_timestamp();\n            assert(block_timestamp > outside_execution.execute_after, 'SNIP9: Too early call');\n            assert(block_timestamp < outside_execution.execute_before, 'SNIP9: Too late call');\n\n            // Kakarot-Specific Validation\n            assert(outside_execution.calls.len() == 1, 'KKRT: Multicall not supported');\n            assert(tx_info.version.into() >= 1_u256, 'KKRT: Deprecated tx version: 0');\n\n            // EOA Validation\n            assert(self.Account_bytecode_len.read().is_zero(), 'EOA: cannot have code');\n\n            let kakarot = IEthRPCDispatcher { contract_address: self.ownable.owner() };\n\n            let chain_id: u64 = kakarot.eth_chain_id();\n            assert(signature.len() == 5, 'EOA: Invalid signature length');\n            let signature = deserialize_signature(signature, chain_id)\n                .expect('EOA: invalid signature');\n\n            let mut encoded_tx_data = deserialize_bytes((*outside_execution.calls[0]).calldata)\n                .expect('conversion to Span<u8> failed')\n                .span();\n            let unsigned_transaction_hash = TransactionTrait::compute_hash(encoded_tx_data);\n\n            let address = self.Account_evm_address.read();\n            verify_eth_signature(unsigned_transaction_hash, signature, address);\n\n            let (success, return_data, gas_used) = kakarot\n                .eth_send_raw_unsigned_tx(encoded_tx_data);\n            let return_data = serialize_bytes(return_data).span();\n\n            // See Argent account\n            // https://github.com/argentlabs/argent-contracts-starknet/blob/1352198956f36fb35fa544c4e46a3507a3ec20e3/src/presets/user_account.cairo#L211-L213\n            // See 300 max data_len for events\n            // https://github.com/starkware-libs/blockifier/blob/9bfb3d4c8bf1b68a0c744d1249b32747c75a4d87/crates/blockifier/resources/versioned_constants.json\n            // The whole data_len should be less than 300, so it's the return_data should be less\n            // than 297 (+3 for return_data_len, success, gas_used)\n            self\n                .emit(\n                    TransactionExecuted {\n                        response: return_data.slice(0, min(297, return_data.len())),\n                        success: success,\n                        gas_used\n                    }\n                );\n            array![return_data]\n        }\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "cairo/kakarot-ssj/crates/contracts/src/cairo1_helpers.cairo",
      "code": "use core::starknet::{EthAddress, secp256_trait::Signature, ContractAddress};\n\n#[starknet::interface]\npub trait IPrecompiles<T> {\n    /// Executes a precompiled contract at a given address with provided data.\n    ///\n    /// # Arguments\n    ///\n    /// * `self` - The instance of the current class.\n    /// * `address` - The address of the precompiled contract to be executed.\n    /// * `data` - The data to be passed to the precompiled contract.\n    ///\n    /// # Returns\n    ///\n    /// * A tuple containing:\n    ///   * True if the execution was successful, false otherwise.\n    ///   * The gas cost of the execution if successful, otherwise 0.\n    ///   * The output data from the execution.\n    fn exec_precompile(self: @T, address: felt252, data: Span<u8>) -> (bool, u64, Span<u8>);\n}\n\n#[starknet::interface]\npub trait IHelpers<T> {\n    /// Gets the hash of a specific StarkNet block within the range of\n    /// [first_v0_12_0_block, current_block - 10].\n    ///\n    /// # Arguments\n    ///\n    /// * `block_number` - The block number for which to get the hash.\n    ///\n    /// # Returns\n    /// The hash of the specified block.\n    ///\n    /// # Errors\n    /// `Block number out of range` - If the block number is greater than `current_block - 10`.\n    /// `0`: The block number is inferior to `first_v0_12_0_block`.\n    fn get_block_hash(self: @T, block_number: u64) -> felt252;\n\n    /// Computes the keccak hash of the provided data.\n    ///\n    /// The data is expected to be an array of full 64-bit words.\n    /// The last u64-word to hash may be incomplete and is provided separately.\n    /// # Arguments\n    ///\n    /// * `words` - The full 64-bit words to hash.\n    /// * `last_input_word` - The last word to hash.\n    /// * `last_input_num_bytes` - The number of bytes in the last word.\n    ///\n    /// # Returns\n    /// The EVM-compatible keccak hash of the provided data.\n    fn keccak(\n        self: @T, words: Array<u64>, last_input_word: u64, last_input_num_bytes: usize\n    ) -> u256;\n\n    /// Computes the SHA-256 of the provided data.\n    ///\n    /// The data is expected to be an array of full 32-bit unsigned words.\n    /// The last u32-word to hash may be incomplete and is provided separately.\n    /// # Arguments\n    ///\n    /// * `input` - The full 32-bit unsigned words to hash.\n    /// * `last_input_word` - the last word to hash.\n    /// * `last_input_num_bytes` - the number of bytes in the last word.\n    ///\n    /// # Returns\n    /// The SHA-256 of the provided data.\n    fn compute_sha256_u32_array(\n        self: @T, input: Array<u32>, last_input_word: u32, last_input_num_bytes: u32\n        ) -> [\n        u32\n    ; 8];\n\n    // DEPRECATED\n    fn verify_eth_signature(\n        self: @T, msg_hash: u256, signature: Signature, eth_address: EthAddress\n    );\n\n    /// Recovers the Ethereum address from a message hash and a signature.\n    ///\n    /// # Arguments\n    ///\n    /// * `msg_hash` - The hash of the message.\n    /// * `signature` - The signature to recover the address from.\n    ///\n    /// # Returns\n    /// A tuple containing:\n    /// * A boolean indicating whether the recovery was successful.\n    /// * The recovered Ethereum address.\n    fn recover_eth_address(self: @T, msg_hash: u256, signature: Signature) -> (bool, EthAddress);\n\n    /// Performs signature verification in the secp256r1 elliptic curve.\n    ///\n    /// # Arguments\n    ///\n    /// * `msg_hash` - The hash of the message.\n    /// * `r` - The r component of the signature.\n    /// * `s` - The s component of the signature.\n    /// * `x` - The x coordinate of the public key.\n    /// * `y` - The y coordinate of the public key.\n    ///\n    /// # Returns\n    /// A boolean indicating whether the signature is valid.\n    fn verify_signature_secp256r1(\n        self: @T, msg_hash: u256, r: u256, s: u256, x: u256, y: u256\n    ) -> bool;\n\n\n    /// Calls a contract using the new Cairo call_contract_syscall.\n    ///\n    /// Meant to be used from Cairo Zero classes that want to be able to manage the return value of\n    /// the call.\n    /// Only applicable from Starknet v0.13.4 and onwwards.\n    ///\n    /// # Arguments\n    ///\n    /// * `to` - The address of the contract to call.\n    /// * `selector` - The selector of the function to call.\n    /// * `calldata` - The calldata to pass to the function.\n    ///\n    /// # Returns\n    /// A tuple containing:\n    /// * A boolean indicating whether the call was successful.\n    /// * The output of the call.\n    fn new_call_contract_syscall(\n        ref self: T, to: ContractAddress, selector: felt252, calldata: Span<felt252>\n    ) -> (bool, Span<felt252>);\n}\n\n\npub mod embeddable_impls {\n    use core::keccak::{cairo_keccak, keccak_u256s_be_inputs};\n    use core::num::traits::Zero;\n    use core::starknet::eth_signature::{verify_eth_signature};\n    use core::starknet::secp256_trait::{\n        Signature, recover_public_key, Secp256PointTrait, is_valid_signature\n    };\n    use core::starknet::secp256_trait::{Secp256Trait};\n    use core::starknet::secp256k1::Secp256k1Point;\n    use core::starknet::secp256r1::{Secp256r1Point};\n    use core::starknet::{ContractAddress, EthAddress};\n    use core::traits::Into;\n    use core::{starknet, starknet::SyscallResultTrait};\n    use evm::errors::EVMError;\n    use evm::precompiles::EcAdd;\n    use evm::precompiles::EcMul;\n    use evm::precompiles::Sha256;\n    use utils::traits::integer::U256Trait;\n\n\n    #[starknet::embeddable]\n    pub impl Precompiles<TContractState> of super::IPrecompiles<TContractState> {\n        fn exec_precompile(\n            self: @TContractState, address: felt252, data: Span<u8>\n        ) -> (bool, u64, Span<u8>) {\n            let result = match address {\n                0 => Result::Err(EVMError::NotImplemented),\n                1 => Result::Err(EVMError::NotImplemented),\n                2 => Sha256::exec(data),\n                3 | 4 => Result::Err(EVMError::NotImplemented),\n                5 => Result::Err(EVMError::NotImplemented),\n                6 => EcAdd::exec(data),\n                7 => EcMul::exec(data),\n                _ => Result::Err(EVMError::NotImplemented),\n            };\n            match result {\n                Result::Ok((gas, output)) => (true, gas, output),\n                Result::Err(_) => (false, 0, [].span())\n            }\n        }\n    }\n\n    #[starknet::embeddable]\n    pub impl Helpers<TContractState, +Drop<TContractState>> of super::IHelpers<TContractState> {\n        fn get_block_hash(self: @TContractState, block_number: u64) -> felt252 {\n            starknet::syscalls::get_block_hash_syscall(block_number).unwrap_syscall()\n        }\n\n        fn keccak(\n            self: @TContractState,\n            mut words: Array<u64>,\n            last_input_word: u64,\n            last_input_num_bytes: usize\n        ) -> u256 {\n            cairo_keccak(ref words, last_input_word, last_input_num_bytes).reverse_endianness()\n        }\n\n        fn compute_sha256_u32_array(\n            self: @TContractState,\n            input: Array<u32>,\n            last_input_word: u32,\n            last_input_num_bytes: u32\n            ) -> [\n            u32\n        ; 8] {\n            core::sha256::compute_sha256_u32_array(input, last_input_word, last_input_num_bytes)\n        }\n\n        // DEPRECATED\n        fn verify_eth_signature(\n            self: @TContractState, msg_hash: u256, signature: Signature, eth_address: EthAddress\n        ) {\n            verify_eth_signature(msg_hash, signature, eth_address);\n        }\n\n        fn recover_eth_address(\n            self: @TContractState, msg_hash: u256, signature: Signature\n        ) -> (bool, EthAddress) {\n            match recover_public_key::<Secp256k1Point>(:msg_hash, :signature) {\n                Option::Some(public_key_point) => {\n                    let (x, y) = public_key_point.get_coordinates().unwrap_syscall();\n                    if (x == 0 && y == 0) {\n                        return (false, Zero::zero());\n                    }\n                    // Keccak output is little endian.\n                    let point_hash_le = keccak_u256s_be_inputs([x, y].span());\n                    let point_hash = u256 {\n                        low: core::integer::u128_byte_reverse(point_hash_le.high),\n                        high: core::integer::u128_byte_reverse(point_hash_le.low)\n                    };\n\n                    (true, point_hash.into())\n                },\n                Option::None => (false, Zero::zero())\n            }\n        }\n\n        fn verify_signature_secp256r1(\n            self: @TContractState, msg_hash: u256, r: u256, s: u256, x: u256, y: u256\n        ) -> bool {\n            let maybe_public_key: Option<Secp256r1Point> = Secp256Trait::secp256_ec_new_syscall(\n                x, y\n            )\n                .unwrap_syscall();\n            let public_key = match maybe_public_key {\n                Option::Some(public_key) => public_key,\n                Option::None => { return false; }\n            };\n\n            return is_valid_signature(msg_hash, r, s, public_key);\n        }\n\n        fn new_call_contract_syscall(\n            ref self: TContractState,\n            to: ContractAddress,\n            selector: felt252,\n            calldata: Span<felt252>\n        ) -> (bool, Span<felt252>) {\n            // Note: until Starknet v0.13.4, the transaction will fail if the call reverted.\n            let result = starknet::syscalls::call_contract_syscall(to, selector, calldata);\n            match result {\n                Result::Ok(output) => { return (true, output); },\n                // This will need to be manually tested and enabled once contract calls can be\n                // handled.\n                Result::Err(error) => { return panic(error); }\n            }\n        }\n    }\n}\n\n#[starknet::contract]\npub mod Cairo1Helpers {\n    #[storage]\n    struct Storage {}\n\n    #[abi(embed_v0)]\n    pub impl Precompiles = super::embeddable_impls::Precompiles<ContractState>;\n\n    #[abi(embed_v0)]\n    pub impl Helpers = super::embeddable_impls::Helpers<ContractState>;\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    },
    {
      "path": "cairo/kakarot-ssj/crates/contracts/src/components.cairo",
      "code": "pub mod ownable;\npub mod upgradeable;\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": true
    }
  ]
}