{
  "meta": {
    "source": "github",
    "repo": {
      "url": "https://github.com/starknet-edu/starknet-cairo-101",
      "stars": 468,
      "forks": 238,
      "last_commit": "2023-12-07T00:08:51Z",
      "archived": true,
      "full_name": "starknet-edu/starknet-cairo-101"
    }
  },
  "files": [
    {
      "path": "src/ex01.cairo",
      "code": "////////////////////////////////\n// Exercise 1\n// Using a simple public contract function\n////////////////////////////////\n// In this exercise, you need to:\n// - Follow this contract's claim_points() function to understand how to finish the exercise\n// - Your points are credited by the contract to your address when you call the claim_points() function successfully (you can call it multiple times)\n// What you'll learn\n// - General smart contract syntax and structure\n////////////////////////////////\n\n// Contracts are defined using the #[contract] attribute (similar to \"contract\" in Solidity) and are defined in a module\n#[contract]\nmod Ex01 {\n    ////////////////////////////////\n    // Core Library imports\n    // These are syscalls and functionalities that allow you to write Starknet contracts\n    ////////////////////////////////\n    use starknet::get_caller_address;\n    use starknet::ContractAddress;\n\n    ////////////////////////////////\n    // Internal imports\n    // These functions become part of the set of functions of the contract\n    ////////////////////////////////\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::validate_exercise;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::ex_initializer;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::distribute_points;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::update_class_hash_by_admin;\n\n    ////////////////////////////////\n    // Constructor\n    // This function (indicated with #[constructor]) is called once, when the contract is deployed, and is used to initialize the contract's state\n    ////////////////////////////////\n    // The constructor takes 4 parameters: the address of the TDERC20 contract, the address of the PlayersRegistry contract, the workshop id and the exercise id\n    // When you deploy the contract, you need to pass these parameters to the constructor function\n    // For these exercises you do not need to worry about the parameters, they are automatically passed to the constructor.\n    #[constructor]\n    fn constructor(_tderc20_address: ContractAddress, _players_registry: ContractAddress, _workshop_id: u128, _exercise_id: u128) {\n        ex_initializer(_tderc20_address, _players_registry, _workshop_id, _exercise_id);\n    }\n\n    ////////////////////////////////\n    // External functions\n    // These functions are callable by other contracts or external calls such as DAPP, which are indicated with #[external] (similar to \"public\" in Solidity)\n    ////////////////////////////////\n    #[external]\n    fn claim_points() {\n        // Reading caller address\n        let sender_address = get_caller_address();\n        // Checking if the user has validated the exercise before\n        validate_exercise(sender_address);\n        // Sending points to the address specified as parameter\n        distribute_points(sender_address, 2_u128);\n    }\n    ////////////////////////////////\n    // External functions - Administration\n    // Only admins can call these. You don't need to understand them to finish the exercise.\n    ////////////////////////////////\n    #[external]\n    fn update_class_hash(class_hash: felt252) {\n        update_class_hash_by_admin(class_hash);\n    }\n\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": false
    },
    {
      "path": "src/ex02.cairo",
      "code": "////////////////////////////////\n// Exercise 2\n// Understanding asserts\n////////////////////////////////\n// In this exercise, you need to:\n// - Follow this contract's claim_points() function to understand how to finish the exercise (Tip: See the my_secret_value() function to get the secret value)\n// - Send the correct value to claim_points() to claim your points\n// - Your points are credited by the contract if you send the correct value\n// What you'll learn\n// - Using asserts\n// - How to declare storage variables\n// - How to read storage variables\n// - How to create getter functions (indicated with #[view]) to read variables\n// - How to use asserts; they are similar to require() in Solidity\n////////////////////////////////\n\n\n#[contract]\nmod Ex02 {\n    ////////////////////////////////\n    // Core Library imports\n    // These are syscalls and functionalities that allow you to write Starknet contracts\n    ////////////////////////////////\n    use starknet::get_caller_address;\n    use starknet::ContractAddress;\n\n    ////////////////////////////////\n    // Internal imports\n    // These functions become part of the set of functions of the contract\n    ////////////////////////////////\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::validate_exercise;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::ex_initializer;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::distribute_points;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::update_class_hash_by_admin;\n\n    ////////////////////////////////\n    // Storage\n    // In Cairo 1, storage is declared in a struct\n    // Storage is not visible by default through the ABI\n    ////////////////////////////////\n    struct Storage {\n        // This variable is a u128, an unsigned integer (only positive values) stored over 128 bits\n        // You can use any of the following types: u8, u16, u32, u64, u128, bool, felt252, ContractAddress\n        // You can also use arrays of any of these types.\n        // For example:  Array::<ContractAddress> for an array of addresses or Array::<u8> for an array of 8 bytes\n        // You can read and write to storage variables using the ::write() and ::read() functions, for example: my_secret_value_storage::write(42)\n        my_secret_value_storage: u128,\n    }\n\n    ////////////////////////////////\n    // View Functions\n    // Public variables should be declared explicitly with a getter function (indicated with #[view]) to be visible through the ABI and callable from other contracts\n    ////////////////////////////////\n    #[view]\n    fn my_secret_value() -> u128 {\n        // The contract read the value with ::read()\n        // You may have noticed that in Cairo 1 all lines end with a semicolon.\n        // But this one doesn't. Why?\n        // Because, in this case, the return value is the result of the function call. The semicolon is not needed.\n        my_secret_value_storage::read()\n    }\n\n    ////////////////////////////////\n    // Constructor\n    // This function (indicated with #[constructor]) is called when the contract is deployed and is used to initialize the contract's state\n    ////////////////////////////////\n    #[constructor]\n    fn constructor(\n        _tderc20_address: ContractAddress,\n        _players_registry: ContractAddress,\n        _workshop_id: u128,\n        _exercise_id: u128,\n        my_secret_value: u128,\n    ) {\n        ex_initializer(_tderc20_address, _players_registry, _workshop_id, _exercise_id);\n        my_secret_value_storage::write(my_secret_value);\n    }\n\n    ////////////////////////////////\n    // External functions\n    // These functions are callable by other contracts or external calls such as DAPP, which are indicated with #[external] (similar to \"public\" in Solidity)\n    ////////////////////////////////\n    #[external]\n    fn claim_points(my_value: u128) {\n        // Reading caller address using the Starknet core library function get_caller_address() (similar to msg.sender in Solidity)\n        // and storing it in a variable called sender_address.\n        let sender_address = get_caller_address();\n        // Reading the secret value from storage using the read function from the storage variable my_secret_value_storage\n        let my_secret_value = my_secret_value_storage::read();\n        // Checking that the value sent is the same as the secret value stored in storage using the assert function\n        // Using assert this way is similar to using \"require\" in Solidity\n        assert(my_value == my_secret_value, 'Wrong secret value');\n        // Checking if the user has validated the exercise before sending points using the validate_exercise function from the Ex00Base contract\n        validate_exercise(sender_address);\n        // Sending points to the address specified as parameter using the distribute_points function from the Ex00Base contract\n        distribute_points(sender_address, 2_u128);\n    }\n    ////////////////////////////////\n    // External functions - Administration\n    // Only admins can call these. You don't need to understand them to finish the exercise.\n    ////////////////////////////////\n    #[external]\n    fn update_class_hash(class_hash: felt252) {\n        update_class_hash_by_admin(class_hash);\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": false
    },
    {
      "path": "src/ex03.cairo",
      "code": "////////////////////////////////\n// Exercise 3\n// Using contract functions to manipulate contract variables\n////////////////////////////////\n// In this exercise, you need to:\n// - Follow this contract's claim_points() function to understand how to finish the exercise\n// - Use this contract's decrement and increment functions in order to manipulate an internal counter\n// - Once this counter reaches a certain value, call a specific function\n// - Your points are credited by the contract\n// What you'll learn\n// - What are external functions and how to declare them in a contract\n// - How to declare mappings in storage variables\n// - How to read and write to mappings\n// - How to use a function to manipulate storage variables\n// - How to return a value from a function\n// - How to throw an error using the Cairo assert function\n////////////////////////////////\n\n#[contract]\nmod Ex03 {\n    ////////////////////////////////\n    // Core Library imports\n    // These are syscalls and functionalities that allow you to write Starknet contracts\n    ////////////////////////////////\n    use starknet::get_caller_address;\n    use starknet::ContractAddress;\n\n    ////////////////////////////////\n    // Internal imports\n    // These functions become part of the set of functions of the contract\n    ////////////////////////////////\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::validate_exercise;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::ex_initializer;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::distribute_points;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::update_class_hash_by_admin;\n\n    ////////////////////////////////\n    // Storage\n    // In Cairo 1, storage is declared in a struct\n    // Storage is not visible by default through the ABI\n    ////////////////////////////////\n    struct Storage {\n        // This variable is a LegacyMap. It is equivalent to a mapping in Solidity.\n        // It is used to store a counter (of type u128) for each user address (of type ContractAddress) in the contract's storage\n        // The user_counters variable is private and can only be accessed through the getter function declared below\n        // To read the u128 value from a LegacyMap, use the read function (e.g. user_counters::read(sender_address))\n        // To write a u128 value to a LegacyMap (mapping a u128 to a ContractAddress), use the write function (e.g. user_counters::write(sender_address, 0_u128))\n        user_counters: LegacyMap::<ContractAddress, u128>,\n    }\n\n    ////////////////////////////////\n    // Constructor\n    // This function (indicated with #[constructor]) is called when the contract is deployed and is used to initialize the contract's state\n    ////////////////////////////////\n    #[constructor]\n    fn constructor(\n        _tderc20_address: ContractAddress, _players_registry: ContractAddress, _workshop_id: u128, _exercise_id: u128\n    ) {\n        ex_initializer(_tderc20_address, _players_registry, _workshop_id, _exercise_id);\n    }\n\n    ////////////////////////////////\n    // View Functions\n    // Public variables should be declared explicitly with a getter function (indicated with #[view]) to be visible through the ABI and callable from other contracts\n    ////////////////////////////////\n    #[view]\n    fn get_user_counters(account: ContractAddress) -> u128 {\n        // We are not calling the read function without any parameter (e.g. user_counters::read()) but with a parameter (e.g. user_counters::read(sender_address))\n        // because we want to read the value of the mapping for a specific key (the sender address)\n        let user_counter = user_counters::read(account);\n        // We return the value of the counter. We can return a value without using the return keyword, similar to Rust\n        user_counter\n    }\n\n    ////////////////////////////////\n    // External functions\n    // These functions are callable by other contracts or external calls and are indicated with #[external] (similar to \"public\" in Solidity)\n    ////////////////////////////////\n    // You can alter the state of the contract by calling external functions such as increment_counter, decrement_counter and reset_counter\n    // After you altered the state of the contract, you can read from the contract's storage using the get_user_counters function to check if the counter is equal to 3\n    // Then you can call the claim_points function to check if the counter is equal to 3 and if so credit the user with points\n    #[external]\n    fn increment_counter() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Reading the counter from storage for the sender address (the key of the mapping) and storing it in a variable\n        let current_counter_value = user_counters::read(sender_address);\n        // Writing updated value to storage (incrementing the counter by 2)\n        user_counters::write(sender_address, current_counter_value + 2_u128);\n    }\n\n    #[external]\n    fn decrement_counter() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Reading counter from storage\n        let current_counter_value = user_counters::read(sender_address);\n        // Writing updated value to storage (decrementing the counter by 1)\n        user_counters::write(sender_address, current_counter_value - 1_u128);\n    }\n\n    #[external]\n    fn reset_counter() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Reinitializing the user counter to 0 (resetting it)\n        user_counters::write(sender_address, 0_u128);\n    }\n\n\n    #[external]\n    fn claim_points() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Checking that user's counter is equal to 3 (the value we want to reach) and throwing an error if it is not\n        let current_counter_value = user_counters::read(sender_address);\n        // We are using the Cairo assert function to throw an error if the condition is not met\n        assert(current_counter_value == 3_u128, 'Counter is not equal to 3');\n\n        // Checking if the user has validated the exercise before\n        validate_exercise(sender_address);\n        // Sending points to the address specified as parameter\n        distribute_points(sender_address, 2_u128);\n    }\n    ////////////////////////////////\n    // External functions - Administration\n    // Only admins can call these. You don't need to understand them to finish the exercise.\n    ////////////////////////////////\n    #[external]\n    fn update_class_hash(class_hash: felt252) {\n        update_class_hash_by_admin(class_hash);\n    }\n\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": false
    },
    {
      "path": "src/ex04.cairo",
      "code": "////////////////////////////////\n// Exercise 4\n// Reading a mapping\n////////////////////////////////\n// In this exercise, you need to:\n// - Follow this contract's claim_points() function to understand how to finish the exercise\n// - Use a function to show you know the correct value of the value in the mapping\n// - Use this contract's claim_points() function with a specific argument\n// - Your points are credited by the contract if you send the correct value\n// What you will learn:\n// - How to use a function to read a value in a mapping where the slot you read is the value from the first call\n////////////////////////////////\n\n\n#[contract]\nmod Ex04 {\n    ////////////////////////////////\n    // Core Library imports\n    // These are syscalls and functionalities that allow you to write Starknet contracts\n    ////////////////////////////////\n    use starknet::get_caller_address;\n    use starknet::ContractAddress;\n    use array::ArrayTrait;\n    use option::OptionTrait;\n\n    ////////////////////////////////\n    // Internal imports\n    // These functions become part of the set of functions of the contract\n    ////////////////////////////////\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::distribute_points;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::validate_exercise;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::ex_initializer;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::update_class_hash_by_admin;\n    use starknet_cairo_101::utils::helper;\n\n    ////////////////////////////////\n    // Storage\n    // In Cairo 1, storage is declared in a struct\n    // Storage is not visible by default through the ABI\n    ////////////////////////////////\n    struct Storage {\n        user_slots: LegacyMap::<ContractAddress, u128>,\n        values_mapped: LegacyMap::<u128, u128>,\n        was_initialized: bool,\n        next_slot: u128,\n    }\n\n    ////////////////////////////////\n    // Constructor\n    // This function (indicated with #[constructor]) is called when the contract is deployed and is used to initialize the contract's state\n    ////////////////////////////////\n    #[constructor]\n    fn constructor(\n        _tderc20_address: ContractAddress, _players_registry: ContractAddress, _workshop_id: u128, _exercise_id: u128\n    ) {\n        ex_initializer(_tderc20_address, _players_registry, _workshop_id, _exercise_id);\n    }\n\n    ////////////////////////////////\n    // View Functions\n    // Public variables should be declared explicitly with a getter function (indicated with #[view]) to be visible through the ABI and callable from other contracts\n    ////////////////////////////////\n    #[view]\n    fn get_user_slots(account: ContractAddress) -> u128 {\n        return user_slots::read(account);\n    }\n\n    #[view]\n    fn get_values_mapped(slot: u128) -> u128 {\n        return values_mapped::read(slot);\n    }\n\n    ////////////////////////////////\n    // External functions\n    // These functions are callable by other contracts or external calls such as DAPP, which are indicated with #[external] (similar to \"public\" in Solidity)\n    ////////////////////////////////\n    #[external]\n    fn claim_points(expected_value: u128) {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Reading the slot assigned to the caller address in the mapping user_slots.\n        // The value was assigned when assign_user_slot() was called by the user (see below) and is stored in the mapping user_slots\n        let user_slot = user_slots::read(sender_address);\n        // Checking that the user has a slot assigned to they (i.e. that he called assign_user_slot() before)\n        assert(user_slot != 0_u128, 'ASSIGN_USER_SLOT_FIRST');\n\n        // Checking that the value provided by the caller is the one we expect\n        // Yes, I'm sneaky\n        let value = values_mapped::read(user_slot);\n        assert(value == expected_value + 32_u128, 'NOT_EXPECTED_SECRET_VALUE');\n\n        // Checking if the user has validated the exercise before\n        validate_exercise(sender_address);\n        // Sending points to the address specified as parameter\n        distribute_points(sender_address, 2_u128);\n    }\n\n    // This function is used to assign a slot to a user and to update the next slot\n    #[external]\n    fn assign_user_slot() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Its value can change during the course of the function call\n        let next_value = values_mapped::read(next_slot::read() + 1_u128);\n        // Checking if next random value is 0\n        if next_value == 0_u128 {\n            next_slot::write(0_u128);\n        }\n        user_slots::write(sender_address, next_slot::read() + 1_u128);\n        next_slot::write(next_slot::read() + 1_u128);\n    }\n\n    ////////////////////////////////\n    // External functions - Administration\n    // Only admins can call these. You don't need to understand them to finish the exercise.\n    ////////////////////////////////\n    #[external]\n    fn update_class_hash(class_hash: felt252) {\n        update_class_hash_by_admin(class_hash);\n    }\n    #[external]\n    fn set_random_values(values: Array::<u128>) {\n        // Check if the random values were already initialized\n        let was_initialized_read = was_initialized::read();\n        assert(was_initialized_read != true, 'NOT_INITIALISED');\n\n        let mut idx: u128 = 0_u128;\n        set_a_random_value(idx, values);\n\n        // Mark that value store was initialized\n        was_initialized::write(true);\n    }\n\n    fn set_a_random_value(mut idx: u128, mut values: Array::<u128>) {\n        helper::check_gas();\n        if !values.is_empty() {\n            values_mapped::write(idx, values.pop_front().unwrap());\n            idx = idx + 1_u128;\n            set_a_random_value(idx, values);\n        }\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": false
    },
    {
      "path": "src/ex05.cairo",
      "code": "////////////////////////////////\n// Exercise 5\n// Public/private variables\n////////////////////////////////\n// In this exercise, you need to:\n// - Follow this contract's claim_points() function to understand how to finish the exercise\n// - Use a function to get assigned a private variable\n// - Use a function to duplicate this variable in a public variable\n// - Use a function to show you know the correct value of the private variable\n// - Your points are credited by the contract\n// What you will learn:\n// - How to interact with private and public variables\n////////////////////////////////\n\n#[contract]\nmod Ex05 {\n    ////////////////////////////////\n    // Core Library imports\n    // These are syscalls and functionalities that allow you to write Starknet contracts\n    ////////////////////////////////\n    use starknet::get_caller_address;\n    use starknet::ContractAddress;\n    use array::ArrayTrait;\n    use option::OptionTrait;\n\n    ////////////////////////////////\n    // Internal imports\n    // These functions become part of the set of functions of the contract\n    ////////////////////////////////\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::distribute_points;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::validate_exercise;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::ex_initializer;\n    use starknet_cairo_101::utils::ex00_base::Ex00Base::update_class_hash_by_admin;\n    use starknet_cairo_101::utils::helper;\n\n    ////////////////////////////////\n    // Storage\n    // In Cairo 1, storage is declared in a struct\n    // Storage is not visible by default through the ABI\n    ////////////////////////////////\n    struct Storage {\n        user_slots: LegacyMap::<ContractAddress, u128>,\n        user_values_public: LegacyMap::<ContractAddress, u128>,\n        values_mapped_secret: LegacyMap::<u128, u128>,\n        was_initialized: bool,\n        next_slot: u128,\n    }\n\n    ////////////////////////////////\n    // Constructor\n    // This function (indicated with #[constructor]) is called when the contract is deployed and is used to initialize the contract's state\n    ////////////////////////////////\n    #[constructor]\n    fn constructor(\n        _tderc20_address: ContractAddress, _players_registry: ContractAddress, _workshop_id: u128, _exercise_id: u128\n    ) {\n        ex_initializer(_tderc20_address, _players_registry, _workshop_id, _exercise_id);\n    }\n\n    ////////////////////////////////\n    // View Functions\n    // Public variables should be declared explicitly with a getter function (indicated with #[view]) to be visible through the ABI and callable from other contracts or DAPP\n    ////////////////////////////////\n    #[view]\n    fn get_user_slots(account: ContractAddress) -> u128 {\n        user_slots::read(account)\n    }\n\n    #[view]\n    fn get_user_values(account: ContractAddress) -> u128 {\n        user_values_public::read(account)\n    }\n\n    ////////////////////////////////\n    // External functions\n    // These functions are callable by other contracts or external calls such as DAPP, which are indicated with #[external] (similar to \"public\" in Solidity)\n    ////////////////////////////////\n    #[external]\n    fn claim_points(expected_value: u128) {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Reading user slot and verifying it's not zero\n        let user_slot = user_slots::read(sender_address);\n        assert(user_slot != 0_u128, 'ASSIGN_USER_SLOT_FIRST');\n\n        // Checking that the value provided by the user is the one we expect\n        // Yes, I'm sneaky\n        let value = values_mapped_secret::read(user_slot);\n        assert(value == expected_value + 32_u128, 'NOT_EXPECTED_SECRET_VALUE');\n\n        // Checking if the user has validated the exercise before\n        validate_exercise(sender_address);\n        // Sending points to the address specified as parameter\n        distribute_points(sender_address, 2_u128);\n    }\n\n    #[external]\n    fn assign_user_slot() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Its value can change during the course of the function call\n        let next_value = values_mapped_secret::read(next_slot::read() + 1_u128);\n        // Checking if next random value is 0\n        if next_value == 0_u128 {\n            next_slot::write(0_u128);\n        }\n        user_slots::write(sender_address, next_slot::read() + 1_u128);\n        next_slot::write(next_slot::read() + 1_u128);\n\n\n    }\n\n    #[external]\n    fn copy_secret_value_to_readable_mapping() {\n        // Reading caller address\n        let sender_address: ContractAddress = get_caller_address();\n        // Reading user's assigned slot and verifying it's not zero\n        let user_slot = user_slots::read(sender_address);\n        assert(user_slot != 0_u128, 'ASSIGN_USER_SLOT_FIRST');\n\n        // Reading user secret value\n        let secret_value = values_mapped_secret::read(user_slot);\n\n        // Copying the value from non accessible values_mapped_secret_storage to publicly accessible user_values_public\n        user_values_public::write(sender_address, secret_value - 23_u128);\n    }\n\n    ////////////////////////////////\n    // External functions - Administration\n    // Only admins can call these. You don't need to understand them to finish the exercise.\n    ////////////////////////////////\n    #[external]\n    fn update_class_hash(class_hash: felt252) {\n        update_class_hash_by_admin(class_hash);\n    }\n\n    #[external]\n    fn set_random_values(values: Array::<u128>) {\n        // Check if the random values were already initialized\n        let was_initialized_read = was_initialized::read();\n        assert(was_initialized_read != true, 'NOT_INITIALISED');\n\n        let mut idx = 0_u128;\n        set_a_random_value(idx, values);\n\n        // Mark that value store was initialized\n        was_initialized::write(true);\n    }\n\n    fn set_a_random_value(mut idx: u128, mut values: Array::<u128>) {\n        helper::check_gas();\n\n        if !values.is_empty() {\n            values_mapped_secret::write(idx, values.pop_front().unwrap());\n            idx = idx + 1_u128;\n            set_a_random_value(idx, values);\n        }\n    }\n}\n",
      "has_tests": true,
      "has_ci": true,
      "has_audit": false
    }
  ]
}